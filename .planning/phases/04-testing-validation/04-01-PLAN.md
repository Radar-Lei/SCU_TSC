---
phase: 04-testing-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pytest.ini
  - tests/__init__.py
  - tests/conftest.py
  - tests/unit/__init__.py
  - tests/unit/test_format_reward.py
  - tests/unit/test_max_pressure.py
  - tests/unit/test_tsc_reward.py
  - tests/unit/test_config.py
  - tests/integration/__init__.py
  - tests/integration/test_integration.py
  - scripts/run_tests.sh
autonomous: true

must_haves:
  truths:
    - "所有单元测试通过且无错误输出（pytest显示X passed, 0 failed）"
    - "运行 pytest -m 'not integration' 只执行单元测试（跳过SUMO依赖）"
    - "运行 ./scripts/run_tests.sh 在docker容器中执行所有测试"
    - "format_reward_fn的边界情况（空输出、错误JSON、有效变体）有完整测试覆盖"
    - "Max Pressure算法的时间约束和压力比较逻辑有完整测试覆盖"
    - "配置加载的参数验证和YAML解析有完整测试覆盖"
  artifacts:
    - path: "pytest.ini"
      provides: "pytest配置（标记注册、测试路径、超时设置）"
      contains: "[pytest]", "markers", "integration"
    - path: "tests/conftest.py"
      provides: "共享fixture（测试数据工厂、SUMO数据fixture）"
      min_lines: 30
    - path: "tests/unit/test_format_reward.py"
      provides: "format_reward_fn边界测试"
      exports: ["test_format_reward_strict_valid_*", "test_format_reward_partial_valid_*", "test_format_reward_invalid_*"]
    - path: "tests/unit/test_max_pressure.py"
      provides: "Max Pressure算法测试"
      exports: ["test_max_pressure_time_constraints_*", "test_max_pressure_decision_*", "test_max_pressure_edge_cases_*"]
    - path: "tests/unit/test_tsc_reward.py"
      provides: "tsc_reward_fn测试（含SUMO集成标记）"
      exports: ["test_tsc_reward_*"]
    - path: "tests/unit/test_config.py"
      provides: "配置加载测试"
      exports: ["test_config_loading_*", "test_config_override_*", "test_config_validation_*"]
    - path: "tests/integration/test_integration.py"
      provides: "基础集成测试（标记为integration）"
      exports: ["test_reward_chain_with_sumo"]
    - path: "scripts/run_tests.sh"
      provides: "docker容器内测试执行脚本"
      min_lines: 100
  key_links:
    - from: "scripts/run_tests.sh"
      to: "docker exec"
      via: "容器内pytest命令执行"
      pattern: "docker exec.*pytest"
    - from: "pytest.ini"
      to: "tests/"
      via: "pytest测试发现"
      pattern: "testpaths.*tests"
    - from: "tests/integration/test_integration.py"
      to: "grpo.reward.batch_compute_reward"
      via: "实际SUMO调用"
      pattern: "batch_compute_reward"
---

<objective>
建立完整的pytest测试基础设施，实现单元测试覆盖关键组件，确保在docker容器中可自动执行测试。

目的：验证reward函数、Max Pressure算法和配置系统的正确性，为端到端测试奠定基础。

输出：pytest配置、单元测试套件、共享fixture、docker测试执行脚本。
</objective>

<execution_context>
@/home/samuel/.claude/get-shit-done/workflows/execute-plan.md
@/home/samuel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-testing-validation/04-CONTEXT.md
@.planning/phases/04-testing-validation/04-RESEARCH.md
@.planning/STATE.md
@.planning/ROADMAP.md

@grpo/reward.py（format_reward_fn、batch_compute_reward）
@grpo/max_pressure.py（max_pressure_decision、max_pressure_decision_from_prompt）
@grpo/config.py（TrainingConfig、load_training_config、参数验证）
@grpo/sumo_reward.py（calculate_tsc_reward_single、normalize_reward）

已存在的测试文件（需迁移/参考）：
@tests/test_config_validation.py（配置验证测试，可作为test_config.py基础）
</context>

<tasks>

<task type="auto">
  <name>创建pytest配置文件</name>
  <files>pytest.ini</files>
  <action>
创建 pytest.ini 文件，配置pytest行为：

1. 注册自定义标记（避免警告）：
   - integration: 标记依赖SUMO/unsloth的集成测试
   - slow: 标记执行时间较长的测试

2. 配置测试路径和发现：
   - testpaths = tests
   - python_files = test_*.py
   - python_classes = Test*
   - python_functions = test_*

3. 配置超时和输出：
   - timeout = 300（单个测试5分钟超时，需pytest-timeout插件）
   - addopts = --strict-markers --tb=short -v

4. 配置日志捕获：
   - log_cli = true
   - log_cli_level = INFO

注意：根据RESEARCH.md，pytest.ini优先级最高且更专注。
  </action>
  <verify>
1. 文件存在：pytest.ini
2. pytest能正确识别配置：pytest --markers
3. 标记已注册且无警告：运行pytest --collect-only无PytestUnknownMarkWarning
4. 验证pytest-timeout已安装：pip show pytest-timeout
  </verify>
  <done>
pytest配置文件存在，运行pytest --markers显示integration标记已注册，pytest-timeout插件已安装。
  </done>
</task>

<task type="auto">
  <name>创建测试目录结构和共享fixture</name>
  <files>tests/__init__.py, tests/conftest.py, tests/unit/__init__.py, tests/integration/__init__.py</files>
  <action>
创建测试目录结构和共享fixture文件：

1. 创建tests/目录结构：
   - tests/__init__.py（空文件，标记为包）
   - tests/unit/__init__.py（空文件）
   - tests/integration/__init__.py（空文件）

2. 创建tests/conftest.py共享fixture：
   - make_prompt()：工厂模式fixture生成测试prompt数据
   - format_reward_test_cases()：format_reward_fn的测试用例数据
   - max_pressure_test_cases()：Max Pressure测试数据
   - sumo_test_data(scope="module")：模块级SUMO测试数据fixture
   - temp_config_file()：临时配置文件fixture（自动清理）

参考RESEARCH.md中的fixture模式：
- 工厂模式fixture返回函数而非数据
- yield fixture确保资源清理
- scope="module"用于SUMO数据共享

3. 确保现有tests/test_config_validation.py的测试可以继续工作
  </action>
  <verify>
1. 目录结构存在：ls -la tests/unit tests/integration
2. conftest.py中的fixture可用：pytest --fixtures显示自定义fixture
3. 测试可导入：python -c "from tests.conftest import *"
  </verify>
  <done>
测试目录结构完整，conftest.py包含共享fixture且pytest可识别。
  </done>
</task>

<task type="auto">
  <name>实现format_reward_fn单元测试</name>
  <files>tests/unit/test_format_reward.py</files>
  <action>
创建tests/unit/test_format_reward.py，覆盖format_reward_fn的所有边界情况：

1. 严格有效格式测试类 TestFormatRewardStrictValid：
   - @pytest.mark.parametrize测试多种严格格式
   - 测试用例：'{"extend": "yes"}', '{"extend": "no"}', '{"extend":"yes"}'（无空格）
   - 验证：reward == 1.0, is_strict == True, is_partial == False

2. 部分有效格式测试类 TestFormatRewardPartialValid：
   - @pytest.mark.parametrize测试部分遵守格式
   - 测试用例：带额外空格、带额外字段、换行、嵌入文本
   - 验证：reward == -0.5, is_strict == False, is_partial == True

3. 无效格式测试类 TestFormatRewardInvalid：
   - @pytest.mark.parametrize测试无效输入
   - 测试用例：空字符串、None、无效JSON、错误extend值
   - 验证：reward == -10.0, is_strict == False, is_partial == False

4. 正则表达式变体测试：
   - 测试自定义regex参数
   - 测试extract_decision函数

使用描述性函数命名（如test_format_reward_strict_valid_json_returns_1_0）。
  </action>
  <verify>
1. pytest tests/unit/test_format_reward.py 通过
2. 测试覆盖所有边界情况：pytest --cov=grpo.reward --cov-report=term-missing
3. 无标记@pytest.mark.integration（纯单元测试）
  </verify>
  <done>
format_reward_fn测试覆盖严格、部分、无效三种格式评分，所有测试通过。
  </done>
</task>

<task type="auto">
  <name>实现Max Pressure算法单元测试</name>
  <files>tests/unit/test_max_pressure.py</files>
  <action>
创建tests/unit/test_max_pressure.py，覆盖Max Pressure算法的所有逻辑：

1. 时间约束测试类 TestMaxPressureTimeConstraints：
   - test_below_min_green_must_extend：green_elapsed < min_green时返回yes
   - test_above_max_green_must_switch：green_elapsed >= max_green时返回no
   - test_at_boundary_conditions：测试边界值（min_green-0.1, max_green+0.1）

2. 压力决策测试类 TestMaxPressureDecision：
   - @pytest.mark.parametrize测试不同排队场景
   - 当前相位排队最大 -> 返回yes
   - 其他相位排队更大 -> 返回no
   - 排队相等 -> 延长当前（yes）

3. 边界情况测试类 TestMaxPressureEdgeCases：
   - test_empty_phase_queues_raises_error：空phase_queues抛ValueError
   - test_missing_current_phase_raises_error：缺少当前相位抛ValueError
   - test_single_phase_always_extend：单相位场景返回yes
   - test_negative_queue_values：负排队数处理

4. prompt解析测试：
   - test_max_pressure_decision_from_prompt_valid_json
   - test_max_pressure_decision_from_prompt_missing_fields
   - test_max_pressure_decision_from_prompt_invalid_json

5. 批量决策测试：
   - test_batch_max_pressure_decision_all_valid
   - test_batch_max_pressure_decision_with_errors（返回'no'保守策略）

使用conftest.py中的make_prompt工厂fixture。
  </action>
  <verify>
1. pytest tests/unit/test_max_pressure.py 通过
2. 时间约束、压力比较、边界情况均有覆盖
3. 无@pytest.mark.integration标记
  </verify>
  <done>
Max Pressure算法测试覆盖时间约束、压力比较和边界情况，所有测试通过。
  </done>
</task>

<task type="auto">
  <name>实现tsc_reward_fn单元测试</name>
  <files>tests/unit/test_tsc_reward.py</files>
  <action>
创建tests/unit/test_tsc_reward.py，覆盖TSC reward计算的关键逻辑：

1. 归一化函数测试类 TestNormalizeReward：
   - @pytest.mark.parametrize测试不同delta值
   - test_normalize_positive_delta：delta > 0 返回负reward
   - test_normalize_negative_delta：delta < 0 返回正reward
   - test_normalize_zero_delta：delta = 0 返回0
   - test_normalize_with_scale：测试不同scale参数
   - test_normalize_extreme_values：极大/极小delta

2. 单样本reward计算测试类（使用mock，避免实际SUMO）：
   - test_calculate_tsc_reward_single_success（mock SUMOInterface）
   - test_calculate_tsc_reward_single_sumo_failure
   - test_calculate_tsc_reward_single_no_traffic_light
   - test_calculate_tsc_reward_extract_decision_failure

3. 批量reward计算测试（标记为integration，需要真实SUMO）：
   - @pytest.mark.integration
   - test_batch_compute_reward_with_real_sumo
   - test_batch_compute_reward_format_skip（format无效时跳过TSC）

4. prompt解析测试：
   - test_parse_prompt_for_decision_info_valid
   - test_parse_prompt_for_decision_info_missing_fields

注意：单元测试使用mock避免SUMO调用，集成测试标记为integration。
  </action>
  <verify>
1. pytest tests/unit/test_tsc_reward.py -m "not integration" 通过（单元测试）
2. pytest tests/unit/test_tsc_reward.py -m integration 在docker中通过（集成测试）
3. 归一化函数测试覆盖多种delta和scale组合
  </verify>
  <done>
tsc_reward_fn测试覆盖归一化逻辑和SUMO集成，单元测试可独立运行。
  </done>
</task>

<task type="auto">
  <name>完善配置加载单元测试</name>
  <files>tests/unit/test_config.py</files>
  <action>
基于现有tests/test_config_validation.py，完善配置测试：

1. 如果tests/test_config_validation.py已存在且内容完整：
   - 将其移动到tests/unit/test_config.py
   - 确保使用pytest风格（非unittest）

2. 如果不完整，补充以下测试：
   - TestConfigLoading类：
     * test_load_valid_config（从config/training_config.yaml加载）
     * test_load_missing_file（文件不存在处理）
     * test_load_invalid_yaml（YAML语法错误）

   - TestConfigOverride类：
     * test_cli_args_override_yaml（模拟sys.argv测试）
     * test_partial_override（只覆盖部分字段）
     * test_nested_config_override（嵌套配置如reward.format）

   - TestConfigValidation类：
     * 合并现有test_config_validation.py的内容
     * 确保所有参数验证测试都在此类中

3. 测试property方法：
   - test_training_config_sft_property
   - test_training_config_grpo_property
   - test_training_config_sumo_property

保留现有的test_config_validation.py内容，迁移到新文件结构中。
  </action>
  <verify>
1. pytest tests/unit/test_config.py 通过
2. 配置验证测试覆盖所有配置类的__post_init__验证
3. YAML加载测试覆盖有效/无效/缺失文件场景
  </verify>
  <done>
配置加载测试覆盖YAML加载、参数验证和CLI覆盖，所有测试通过。
  </done>
</task>

<task type="auto">
  <name>创建基础集成测试文件</name>
  <files>tests/integration/test_integration.py</files>
  <action>
创建tests/integration/test_integration.py，实现基础集成测试：

1. 文件级别标记：pytestmark = pytest.mark.integration

2. test_reward_chain_with_sumo：
   - 使用真实的SUMO仿真（小规模数据）
   - 测试batch_compute_reward函数
   - 验证format和tsc reward的组合
   - 验证reward统计信息

3. test_end_to_end_reward_calculation：
   - 完整测试单个样本的reward计算流程
   - 从prompt解析 -> format检查 -> SUMO仿真 -> reward计算
   - 验证每一步的中间结果

4. fixture：
   - small_sumo_dataset(scope="module)：小规模SUMO测试数据
   - 使用tests/fixtures/testdata/中的现有SUMO状态文件（如果存在）

注意：所有测试标记为integration，可使用-m integration单独运行。
  </action>
  <verify>
1. pytest tests/integration/test_integration.py 在docker容器中通过
2. pytest -m "not integration" 跳过此文件中的测试
3. 测试使用真实SUMO数据（非mock）
  </verify>
  <done>
集成测试文件存在，在docker容器中可成功运行SUMO相关测试。
  </done>
</task>

<task type="auto">
  <name>创建docker测试执行脚本</name>
  <files>scripts/run_tests.sh</files>
  <action>
创建scripts/run_tests.sh脚本，自动化docker容器内的测试执行：

1. 脚本功能：
   - 自动检测docker容器是否运行
   - 在容器内执行pytest命令
   - 支持单元测试/集成测试过滤
   - 支持失败继续模式（--maxfail=999）
   - 彩色输出和进度指示

2. 命令行参数：
   - -u, --unit-only：只运行单元测试（-m "not integration"）
   - -i, --integration：只运行集成测试（-m integration）
   - -a, --all：运行所有测试（默认）
   - -k, --keep-going：遇到失败继续运行
   - -v, --verbose：详细输出
   - -h, --help：显示帮助

3. Docker配置：
   - CONTAINER_NAME="${CONTAINER_NAME:-qwen3-tsc-grpo}"
   - CONTAINER_WORKDIR="${CONTAINER_WORKDIR:-/home/samuel/SCU_TSC}"

4. 错误处理：
   - 容器未运行时提示启动容器
   - 测试失败时收集所有错误信息
   - 使用set -euo pipefail确保错误传播

5. 可执行权限：
   - 创建后添加chmod +x scripts/run_tests.sh

参考RESEARCH.md中的示例脚本和docker/publish.sh的现有模式。
  </action>
  <verify>
1. 脚本存在且可执行：ls -la scripts/run_tests.sh
2. ./scripts/run_tests.sh --help 显示帮助信息
3. ./scripts/run_tests.sh -u 在docker中运行单元测试
4. ./scripts/run_tests.sh -i 在docker中运行集成测试
  </verify>
  <done>
run_tests.sh脚本可在docker中执行测试，支持单元/集成测试过滤。
  </done>
</task>

</tasks>

<verification>
1. pytest可自动发现并执行所有单元测试：
   pytest tests/unit/ -v

2. 单元测试可独立运行（无SUMO依赖）：
   pytest -m "not integration"

3. 集成测试在docker容器中可运行：
   docker exec qwen3-tsc-grpo pytest -m integration

4. run_tests.sh脚本可自动执行测试：
   ./scripts/run_tests.sh -u（单元测试）
   ./scripts/run_tests.sh -i（集成测试）
   ./scripts/run_tests.sh -a -k（全部测试，失败继续）

5. 测试覆盖率：
   - format_reward_fn：严格、部分、无效三种格式
   - Max Pressure：时间约束、压力比较、边界情况
   - 配置加载：YAML解析、参数验证、CLI覆盖
</verification>

<success_criteria>
1. pytest配置正确，运行pytest --collect-only无警告
2. 所有单元测试通过：pytest tests/unit/
3. 集成测试在docker中通过：pytest -m integration
4. run_tests.sh脚本可成功执行测试
5. 测试覆盖format_reward_fn、Max Pressure、配置加载的所有边界情况
</success_criteria>

<output>
完成后创建 .planning/phases/04-testing-validation/04-01-SUMMARY.md
</output>
